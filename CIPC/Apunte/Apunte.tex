%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%            COMPETITIVE PROGRAMMING REFERENCE NOTEBOOK
%
%   A collection of algorithms and data structures for contests
%   like ICPC and IOI.
%
%   Author: F-Patata2008 (Generated by AI Assistant)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[10pt]{article}

%========= Packages ===========
\usepackage[a4paper, margin=0.7in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{titlesec}
\usepackage{enumitem} % For custom lists
\usepackage{booktabs} % For professional-looking tables

%========= Hyperref Setup ===========
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Competitive Programming Notebook},
    pdfpagemode=FullScreen,
}

%========= Listings (Code) Style ===========
\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen}\itshape,
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle, language=C++}

%========= Title Formatting ===========
\titleformat*{\section}{\large\bfseries}
\titleformat*{\subsection}{\normalsize\bfseries}
\titleformat*{\subsubsection}{\normalsize\bfseries\itshape}


%========= Custom list for STL functions ===========
\setlist[itemize]{noitemsep, topsep=0pt, leftmargin=*}
\newcommand{\code}[1]{\texttt{#1}}

%========= Document Metadata ===========
\title{\Huge\bfseries Competitive Programming Notebook}
\author{\large F-Patata2008}
\date{\today}

%========= Begin Document ===========
\begin{document}
\columnsep=1cm
\begin{multicols}{2} % Use two-column layout for compactness

\maketitle
\tableofcontents
\newpage

%-------------------------------------------------
\section{Core Template \& Macros}
%-------------------------------------------------
A robust starting template with fast I/O and common typedefs.

\subsection{The "Papa" Snippet (Single Task)}
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

// Type Aliases
using ll = long long;
using str = string;
using vec = vector;

// Macros for convenience
#define all(x) begin(x), end(x)
#define F first
#define S second
#define pb push_back

// Fast I/O
void setIO(str name = "") {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    if (name.size()) {
        freopen((name + ".in").c_str(), "r", stdin);
        freopen((name + ".out").c_str(), "w", stdout);
    }
}

int main() {
    setIO();
    // Your code here
    return 0;
}
\end{lstlisting}

\subsection{The "Patata" Snippet (Multi-Task)}
\begin{lstlisting}
// ... (includes and setup from above)

void solve() {
    // Logic for a single test case
}

int main() {
    setIO();
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
\end{lstlisting}

%-------------------------------------------------
\section{C++ STL Essentials}
%-------------------------------------------------
The Standard Template Library is your best friend.

\subsection{Vector}
Dynamic array. Use \code{vec<int> v;}.
\begin{itemize}
    \item \code{v.push_back(val)}: Add to end. O(1) amortized.
    \item \code{v.pop_back()}: Remove from end. O(1).
    \item \code{v.size()}: Number of elements.
    \item \code{v.begin()}, \code{v.end()}: Iterators to start and past-the-end.
    \item \code{sort(all(v))}: Sorts vector. O(N log N).
\end{itemize}

\subsection{Set / Multiset}
Stores sorted, unique elements (\code{set}) or duplicates allowed (\code{multiset}). Backed by a balanced binary search tree.
\begin{itemize}
    \item \code{s.insert(val)}: Add element. O(log N).
    \item \code{s.erase(val)}: Remove element. O(log N).
    \item \code{s.count(val)}: Check for presence. O(log N).
    \item \code{s.lower_bound(val)}: Iterator to first element $\ge$ val.
    \item \code{s.upper_bound(val)}: Iterator to first element > val.
    \item `*s.begin()`, `*s.rbegin()`: Smallest/largest element.
\end{itemize}

\subsection{Map}
Key-value pairs, sorted by key.
\begin{itemize}
    \item \code{m[key] = val}: Assign value to key. O(log N).
    \item \code{m.count(key)}: Check if key exists.
    \item \textbf{Note}: \code{unordered_map} is O(1) on average but can have hash collisions.
\end{itemize}

\subsection{Priority Queue}
Max-heap by default.
\begin{itemize}
    \item \code{pq.push(val)}: Add element. O(log N).
    \item \code{pq.pop()}: Remove top (largest). O(log N).
    \item \code{pq.top()}: Access top (largest). O(1).
\end{itemize}
For a min-heap: \code{priority_queue<int, vec<int>, greater<int>> pq;}.

\subsection{Common \texttt{<algorithm>} Functions}
\begin{itemize}
    \item \code{sort(all(v))}: O(N log N).
    \item \code{reverse(all(v))}: O(N).
    \item \code{min_element(all(v))}, \code{max_element(all(v))}. O(N).
    \item \code{lower_bound(all(v), val)}: On a \textit{sorted} range. O(log N).
    \item \code{next_permutation(all(v))}.
\end{itemize}


\newpage
%-------------------------------------------------
\section{Big O Notation \& Time Complexity}
%-------------------------------------------------
Big O describes how an algorithm's runtime or space usage scales with the input size, \code{N}. It focuses on the worst-case scenario and ignores constants.

\subsubsection{Common Complexities (Fastest to Slowest)}
\begin{itemize}
    \item \code{O(1)}: \textbf{Constant}. The operation takes the same amount of time regardless of the input size. Ex: Accessing an array element \code{arr[i]}.
    \item \code{O(log N)}: \textbf{Logarithmic}. Runtime grows logarithmically. Very fast. Ex: Binary search on a sorted array.
    \item \code{O(N)}: \textbf{Linear}. Runtime grows linearly with \code{N}. Ex: Iterating through a list or array.
    \item \code{O(N log N)}: \textbf{Log-linear}. The standard for efficient sorting algorithms. Ex: \code{std::sort}.
    \item \code{O(N^2)}: \textbf{Quadratic}. Common for algorithms with nested loops over the same data. Ex: Naive bubble sort, iterating through pairs in an array.
    \item \code{O(2^N)}: \textbf{Exponential}. Grows very quickly. Often seen in recursive solutions that try all possible subsets. Ex: Brute-force subset sum.
    \item \code{O(N!)}: \textbf{Factorial}. Extremely slow. Ex: Brute-force traveling salesman problem, generating all permutations.
\end{itemize}

\subsubsection{Rule of Thumb for Time Limits}
Most competitive programming servers can run about \textbf{10\textsuperscript{8} operations per second}. Use this to estimate if your solution is fast enough.

\begin{small}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Input Size (N)} & \textbf{Required Complexity} \\
\midrule
\code{N <= 12} & \code{O(N!)} \\
\code{N <= 22} & \code{O(2^N)} \\
\code{N <= 100} & \code{O(N^4)} or \code{O(N^3)} \\
\code{N <= 2,000} & \code{O(N^2)} \\
\code{N <= 200,000} & \code{O(N log N)} \\
\code{N <= 2,000,000} & \code{O(N)} \\
\code{N > 10^9} & \code{O(log N)} or \code{O(sqrt(N))} \\
\bottomrule
\end{tabular}
\end{small}

%-------------------------------------------------
\section{Searching Algorithms}
%-------------------------------------------------

\subsection{Binary Search on Answer}
Finds the minimum value `x` in `[lo, hi]` for which `check(x)` is true. Assumes that `check` is monotonic. Complexity: O(log(range) * O(check)).

\begin{lstlisting}
ll lo = 0, hi = 1e9;
ll ans = hi;

while (lo <= hi) {
    ll mid = lo + (hi - lo) / 2;
    if (check(mid)) {
        ans = mid;
        hi = mid - 1; // Try for an even smaller value
    } else {
        lo = mid + 1;
    }
}
// `ans` holds the result
\end{lstlisting}

\newpage
%-------------------------------------------------
\section{Graph Algorithms}
%-------------------------------------------------
For a graph with V vertices and E edges. Adj. list: `vec<vec<int>> adj;`

\subsection{Depth First Search (DFS)}
Recursive traversal exploring as far as possible along each branch before backtracking. Complexity: O(V + E).

\begin{lstlisting}
vec<bool> visited;
vec<vec<int>> adj;

void dfs(int u) {
    visited[u] = true;
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v);
        }
    }
}
\end{lstlisting}

\subsection{Breadth First Search (BFS)}
Level-order traversal. Finds the shortest path in unweighted graphs. Complexity: O(V + E).

\begin{lstlisting}
vec<int> dist;
vec<vec<int>> adj;

void bfs(int start_node) {
    dist.assign(adj.size(), -1);
    queue<int> q;
    dist[start_node] = 0;
    q.push(start_node);

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}
\end{lstlisting}

\subsection{Dijkstra's Algorithm}
Finds shortest paths from a single source in a graph with non-negative edge weights. Complexity: O(E log V) with a priority queue.

\begin{lstlisting}
using pi = pair<ll, int>; // {distance, node}
const ll INF = 1e18;

vec<ll> dist;
vec<vec<pi>> adj; // {neighbor, weight}

void dijkstra(int start) {
    dist.assign(adj.size(), INF);
    priority_queue<pi, vec<pi>, greater<pi>> pq;

    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d > dist[u]) continue;

        for (auto& edge : adj[u]) {
            int v = edge.first;
            ll weight = edge.second;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}
\end{lstlisting}

\subsection{Topological Sort (Kahn's Algo)}
Linear ordering of vertices in a Directed Acyclic Graph (DAG). Complexity: O(V + E).

\begin{lstlisting}
vec<int> topo_sort(vec<vec<int>>& adj) {
    int n = adj.size();
    vec<int> in_degree(n, 0);
    for (int u = 0; u < n; ++u) {
        for (int v : adj[u]) in_degree[v]++;
    }

    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (in_degree[i] == 0) q.push(i);
    }

    vec<int> result;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        result.pb(u);
        for (int v : adj[u]) {
            if (--in_degree[v] == 0) q.push(v);
        }
    }
    // If result.size() != n, graph has a cycle
    return result;
}
\end{lstlisting}

\newpage
%-------------------------------------------------
\section{Data Structures}
%-------------------------------------------------

\subsection{Disjoint Set Union (DSU)}
Manages a partition of a set into disjoint subsets. Nearly constant time O($\alpha$(N)) per operation.

\begin{lstlisting}
struct DSU {
    vec<int> parent;
    vec<int> sz;
    DSU(int n) {
        parent.resize(n);
        iota(all(parent), 0);
        sz.assign(n, 1);
    }

    int find(int i) {
        if (parent[i] == i) return i;
        return parent[i] = find(parent[i]);
    }

    void unite(int i, int j) {
        int root_i = find(i);
        int root_j = find(j);
        if (root_i != root_j) {
            if (sz[root_i] < sz[root_j])
                swap(root_i, root_j);
            parent[root_j] = root_i;
            sz[root_i] += sz[root_j];
        }
    }
};
\end{lstlisting}

\subsection{Segment Tree (Range Sum)}
For fast range queries and point updates. Build: O(N). Query/Update: O(log N).

\begin{lstlisting}
struct SegTree {
    int size; vec<ll> sums;
    void init(int n) {
        size = 1;
        while (size < n) size *= 2;
        sums.assign(2 * size, 0LL);
    }
    void set(int i, int v, int x, int lx, int rx) {
        if (rx - lx == 1) { sums[x] = v; return; }
        int m = (lx + rx) / 2;
        if (i < m) set(i, v, 2*x+1, lx, m);
        else set(i, v, 2*x+2, m, rx);
        sums[x] = sums[2*x+1] + sums[2*x+2];
    }
    void set(int i, int v) { set(i, v, 0, 0, size); }
    ll sum(int l, int r, int x, int lx, int rx) {
        if (lx >= r || l >= rx) return 0;
        if (lx >= l && rx <= r) return sums[x];
        int m = (lx + rx) / 2;
        return sum(l, r, 2*x+1, lx, m) + sum(l, r, 2*x+2, m, rx);
    }
    ll sum(int l, int r) { return sum(l, r, 0, 0, size); }
};
\end{lstlisting}

\newpage
%-------------------------------------------------
\section{Dynamic Programming}
%-------------------------------------------------

\subsection{0/1 Knapsack}
Given N items, find max value for capacity W. Complexity: O(N * W).

\begin{lstlisting}
int knapsack(int W, const vec<int>& wt, const vec<int>& val) {
    int n = wt.size();
    vec<int> dp(W + 1, 0);

    for (int i = 0; i < n; ++i) {
        for (int w = W; w >= wt[i]; --w) {
            dp[w] = max(dp[w], val[i] + dp[w - wt[i]]);
        }
    }
    return dp[W];
}
\end{lstlisting}

\subsection{Longest Common Subsequence}
Find LCS of two strings. Complexity: O(len1 * len2).

\begin{lstlisting}
int lcs(const str& s1, const str& s2) {
    int m = s1.length(), n = s2.length();
    vec<vec<int>> dp(m + 1, vec<int>(n + 1, 0));
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = 1 + dp[i-1][j-1];
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
\end{stlisting}

%-------------------------------------------------
\section{Number Theory}
%-------------------------------------------------

\subsection{Sieve of Eratosthenes}
Finds primes up to N. Complexity: O(N log log N).

\begin{lstlisting}
const int N = 1000000;
vec<bool> is_prime(N + 1, true);

void sieve() {
    is_prime[0] = is_prime[1] = false;
    for (int p = 2; p * p <= N; ++p) {
        if (is_prime[p]) {
            for (int i = p * p; i <= N; i += p)
                is_prime[i] = false;
        }
    }
}
\end{lstlisting}

\subsection{Modular Exponentiation}
Calculates `(base^exp) % mod`. Complexity: O(log exp).

\begin{lstlisting}
ll power(ll base, ll exp, ll mod) {
    ll res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return res;
}
\end{lstlisting}

\subsection{GCD and LCM}
Uses `std::gcd` from `<numeric>` (C++17). Complexity: O(log(min(a,b))).

\begin{lstlisting}
ll lcm(ll a, ll b) {
    if (a == 0 || b == 0) return 0;
    return abs(a * b) / std::gcd(a, b);
}
\end{lstlisting}

\end{multicols}
\end{document}
